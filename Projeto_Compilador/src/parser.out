Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    APOSTROPHE
    CASE
    COMMENT
    CONST
    FILE
    GOTO
    LABEL
    NIL
    PACKED
    PROCEDURE
    READ
    RECORD
    REPEAT
    SET
    TYPE
    UNTIL
    WITH

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON block PERIOD
Rule 2     block -> declarations compound_statement
Rule 3     declarations -> VAR var_declarations
Rule 4     declarations -> function_declaration
Rule 5     declarations -> empty
Rule 6     function_block -> VAR var_declarations compound_statement
Rule 7     function_block -> compound_statement
Rule 8     declaration -> VAR var_declarations
Rule 9     declaration -> function_declaration
Rule 10    var_declarations -> var_declarations var_declaration
Rule 11    var_declarations -> var_declaration
Rule 12    var_declaration -> id_list COLON type_spec SEMICOLON
Rule 13    id_list -> id_list COMMA ID
Rule 14    id_list -> ID
Rule 15    type_spec -> INTEGER_TYPE
Rule 16    type_spec -> REAL_TYPE
Rule 17    type_spec -> BOOLEAN
Rule 18    type_spec -> STRING_TYPE
Rule 19    type_spec -> CHAR_TYPE
Rule 20    type_spec -> array_type
Rule 21    array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec
Rule 22    compound_statement -> BEGIN statement_list END
Rule 23    statement_list -> statement_list SEMICOLON statement
Rule 24    statement_list -> statement
Rule 25    statement -> compound_statement
Rule 26    statement -> assignment_statement
Rule 27    statement -> if_statement
Rule 28    statement -> while_statement
Rule 29    statement -> for_statement
Rule 30    statement -> procedure_call_statement
Rule 31    statement -> halt_statement
Rule 32    statement -> empty
Rule 33    assignment_statement -> variable ASSIGN expression
Rule 34    variable -> ID
Rule 35    variable -> ID LBRACKET expression RBRACKET
Rule 36    if_statement -> IF expression THEN statement
Rule 37    if_statement -> IF expression THEN statement ELSE statement
Rule 38    while_statement -> WHILE expression DO statement
Rule 39    for_statement -> FOR ID ASSIGN expression TO expression DO statement
Rule 40    for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement
Rule 41    procedure_call_statement -> ID LPAREN expression_list RPAREN
Rule 42    procedure_call_statement -> ID LPAREN RPAREN
Rule 43    procedure_call_statement -> WRITELN LPAREN expression_list RPAREN
Rule 44    procedure_call_statement -> WRITELN LPAREN RPAREN
Rule 45    procedure_call_statement -> WRITE LPAREN expression_list RPAREN
Rule 46    procedure_call_statement -> WRITE LPAREN RPAREN
Rule 47    procedure_call_statement -> READLN LPAREN variable RPAREN
Rule 48    procedure_call_statement -> READLN LPAREN RPAREN
Rule 49    expression_list -> expression_list COMMA expression
Rule 50    expression_list -> expression
Rule 51    expression -> simple_expression
Rule 52    expression -> simple_expression relop simple_expression
Rule 53    relop -> EQ
Rule 54    relop -> NEQ
Rule 55    relop -> LT
Rule 56    relop -> LE
Rule 57    relop -> GT
Rule 58    relop -> GE
Rule 59    relop -> IN
Rule 60    simple_expression -> term
Rule 61    simple_expression -> simple_expression addop term
Rule 62    addop -> PLUS
Rule 63    addop -> MINUS
Rule 64    addop -> OR
Rule 65    term -> factor
Rule 66    term -> term mulop factor
Rule 67    mulop -> TIMES
Rule 68    mulop -> DIVIDE
Rule 69    mulop -> DIV
Rule 70    mulop -> MOD
Rule 71    mulop -> AND
Rule 72    factor -> variable
Rule 73    factor -> INTEGER
Rule 74    factor -> REAL
Rule 75    factor -> STRING
Rule 76    factor -> TRUE
Rule 77    factor -> FALSE
Rule 78    factor -> LPAREN expression RPAREN
Rule 79    factor -> NOT factor
Rule 80    factor -> function_call
Rule 81    expression -> variable COLON INTEGER
Rule 82    expression -> variable COLON INTEGER COLON INTEGER
Rule 83    function_call -> ID LPAREN expression_list RPAREN
Rule 84    function_call -> ID LPAREN RPAREN
Rule 85    function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
Rule 86    param_list -> param_list SEMICOLON param
Rule 87    param_list -> param
Rule 88    param -> id_list COLON type_spec
Rule 89    halt_statement -> HALT SEMICOLON
Rule 90    empty -> <empty>

Terminals, with rules where they appear

AND                  : 71
APOSTROPHE           : 
ARRAY                : 21
ASSIGN               : 33 39 40
BEGIN                : 22
BOOLEAN              : 17
CASE                 : 
CHAR_TYPE            : 19
COLON                : 12 81 82 82 85 88
COMMA                : 13 49
COMMENT              : 
CONST                : 
DIV                  : 69
DIVIDE               : 68
DO                   : 38 39 40
DOWNTO               : 40
ELSE                 : 37
END                  : 22
EQ                   : 53
FALSE                : 77
FILE                 : 
FOR                  : 39 40
FUNCTION             : 85
GE                   : 58
GOTO                 : 
GT                   : 57
HALT                 : 89
ID                   : 1 13 14 34 35 39 40 41 42 83 84 85
IF                   : 36 37
IN                   : 59
INTEGER              : 21 21 73 81 82 82
INTEGER_TYPE         : 15
LABEL                : 
LBRACKET             : 21 35
LE                   : 56
LPAREN               : 41 42 43 44 45 46 47 48 78 83 84 85
LT                   : 55
MINUS                : 63
MOD                  : 70
NEQ                  : 54
NIL                  : 
NOT                  : 79
OF                   : 21
OR                   : 64
PACKED               : 
PERIOD               : 1 21 21
PLUS                 : 62
PROCEDURE            : 
PROGRAM              : 1
RBRACKET             : 21 35
READ                 : 
READLN               : 47 48
REAL                 : 74
REAL_TYPE            : 16
RECORD               : 
REPEAT               : 
RPAREN               : 41 42 43 44 45 46 47 48 78 83 84 85
SEMICOLON            : 1 12 23 85 85 86 89
SET                  : 
STRING               : 75
STRING_TYPE          : 18
THEN                 : 36 37
TIMES                : 67
TO                   : 39
TRUE                 : 76
TYPE                 : 
UNTIL                : 
VAR                  : 3 6 8
WHILE                : 38
WITH                 : 
WRITE                : 45 46
WRITELN              : 43 44
error                : 

Nonterminals, with rules where they appear

addop                : 61
array_type           : 20
assignment_statement : 26
block                : 1
compound_statement   : 2 6 7 25
declaration          : 
declarations         : 2
empty                : 5 32
expression           : 33 35 36 37 38 39 39 40 40 49 50 78
expression_list      : 41 43 45 49 83
factor               : 65 66 79
for_statement        : 29
function_block       : 85
function_call        : 80
function_declaration : 4 9
halt_statement       : 31
id_list              : 12 13 88
if_statement         : 27
mulop                : 66
param                : 86 87
param_list           : 85 86
procedure_call_statement : 30
program              : 0
relop                : 52
simple_expression    : 51 52 52 61
statement            : 23 24 36 37 37 38 39 40
statement_list       : 22 23
term                 : 60 61 66
type_spec            : 12 21 85 88
var_declaration      : 10 11
var_declarations     : 3 6 8 10
variable             : 33 47 72 81 82
while_statement      : 28

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON block PERIOD

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON block PERIOD

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON block PERIOD

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . block PERIOD
    (2) block -> . declarations compound_statement
    (3) declarations -> . VAR var_declarations
    (4) declarations -> . function_declaration
    (5) declarations -> . empty
    (85) function_declaration -> . FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (90) empty -> .

    VAR             shift and go to state 7
    FUNCTION        shift and go to state 10
    BEGIN           reduce using rule 90 (empty -> .)

    block                          shift and go to state 5
    declarations                   shift and go to state 6
    function_declaration           shift and go to state 8
    empty                          shift and go to state 9

state 5

    (1) program -> PROGRAM ID SEMICOLON block . PERIOD

    PERIOD          shift and go to state 11


state 6

    (2) block -> declarations . compound_statement
    (22) compound_statement -> . BEGIN statement_list END

    BEGIN           shift and go to state 13

    compound_statement             shift and go to state 12

state 7

    (3) declarations -> VAR . var_declarations
    (10) var_declarations -> . var_declarations var_declaration
    (11) var_declarations -> . var_declaration
    (12) var_declaration -> . id_list COLON type_spec SEMICOLON
    (13) id_list -> . id_list COMMA ID
    (14) id_list -> . ID

    ID              shift and go to state 17

    var_declarations               shift and go to state 14
    var_declaration                shift and go to state 15
    id_list                        shift and go to state 16

state 8

    (4) declarations -> function_declaration .

    BEGIN           reduce using rule 4 (declarations -> function_declaration .)


state 9

    (5) declarations -> empty .

    BEGIN           reduce using rule 5 (declarations -> empty .)


state 10

    (85) function_declaration -> FUNCTION . ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON

    ID              shift and go to state 18


state 11

    (1) program -> PROGRAM ID SEMICOLON block PERIOD .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON block PERIOD .)


state 12

    (2) block -> declarations compound_statement .

    PERIOD          reduce using rule 2 (block -> declarations compound_statement .)


state 13

    (22) compound_statement -> BEGIN . statement_list END
    (23) statement_list -> . statement_list SEMICOLON statement
    (24) statement_list -> . statement
    (25) statement -> . compound_statement
    (26) statement -> . assignment_statement
    (27) statement -> . if_statement
    (28) statement -> . while_statement
    (29) statement -> . for_statement
    (30) statement -> . procedure_call_statement
    (31) statement -> . halt_statement
    (32) statement -> . empty
    (22) compound_statement -> . BEGIN statement_list END
    (33) assignment_statement -> . variable ASSIGN expression
    (36) if_statement -> . IF expression THEN statement
    (37) if_statement -> . IF expression THEN statement ELSE statement
    (38) while_statement -> . WHILE expression DO statement
    (39) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (40) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (41) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (42) procedure_call_statement -> . ID LPAREN RPAREN
    (43) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (44) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (45) procedure_call_statement -> . WRITE LPAREN expression_list RPAREN
    (46) procedure_call_statement -> . WRITE LPAREN RPAREN
    (47) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (48) procedure_call_statement -> . READLN LPAREN RPAREN
    (89) halt_statement -> . HALT SEMICOLON
    (90) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    BEGIN           shift and go to state 13
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32
    ID              shift and go to state 33
    WRITELN         shift and go to state 34
    WRITE           shift and go to state 35
    READLN          shift and go to state 36
    HALT            shift and go to state 37
    END             reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)

    statement_list                 shift and go to state 19
    statement                      shift and go to state 20
    compound_statement             shift and go to state 21
    assignment_statement           shift and go to state 22
    if_statement                   shift and go to state 23
    while_statement                shift and go to state 24
    for_statement                  shift and go to state 25
    procedure_call_statement       shift and go to state 26
    halt_statement                 shift and go to state 27
    empty                          shift and go to state 28
    variable                       shift and go to state 29

state 14

    (3) declarations -> VAR var_declarations .
    (10) var_declarations -> var_declarations . var_declaration
    (12) var_declaration -> . id_list COLON type_spec SEMICOLON
    (13) id_list -> . id_list COMMA ID
    (14) id_list -> . ID

    BEGIN           reduce using rule 3 (declarations -> VAR var_declarations .)
    ID              shift and go to state 17

    var_declaration                shift and go to state 38
    id_list                        shift and go to state 16

state 15

    (11) var_declarations -> var_declaration .

    ID              reduce using rule 11 (var_declarations -> var_declaration .)
    BEGIN           reduce using rule 11 (var_declarations -> var_declaration .)


state 16

    (12) var_declaration -> id_list . COLON type_spec SEMICOLON
    (13) id_list -> id_list . COMMA ID

    COLON           shift and go to state 39
    COMMA           shift and go to state 40


state 17

    (14) id_list -> ID .

    COLON           reduce using rule 14 (id_list -> ID .)
    COMMA           reduce using rule 14 (id_list -> ID .)


state 18

    (85) function_declaration -> FUNCTION ID . LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON

    LPAREN          shift and go to state 41


state 19

    (22) compound_statement -> BEGIN statement_list . END
    (23) statement_list -> statement_list . SEMICOLON statement

    END             shift and go to state 42
    SEMICOLON       shift and go to state 43


state 20

    (24) statement_list -> statement .

    END             reduce using rule 24 (statement_list -> statement .)
    SEMICOLON       reduce using rule 24 (statement_list -> statement .)


state 21

    (25) statement -> compound_statement .

    END             reduce using rule 25 (statement -> compound_statement .)
    SEMICOLON       reduce using rule 25 (statement -> compound_statement .)
    ELSE            reduce using rule 25 (statement -> compound_statement .)


state 22

    (26) statement -> assignment_statement .

    END             reduce using rule 26 (statement -> assignment_statement .)
    SEMICOLON       reduce using rule 26 (statement -> assignment_statement .)
    ELSE            reduce using rule 26 (statement -> assignment_statement .)


state 23

    (27) statement -> if_statement .

    END             reduce using rule 27 (statement -> if_statement .)
    SEMICOLON       reduce using rule 27 (statement -> if_statement .)
    ELSE            reduce using rule 27 (statement -> if_statement .)


state 24

    (28) statement -> while_statement .

    END             reduce using rule 28 (statement -> while_statement .)
    SEMICOLON       reduce using rule 28 (statement -> while_statement .)
    ELSE            reduce using rule 28 (statement -> while_statement .)


state 25

    (29) statement -> for_statement .

    END             reduce using rule 29 (statement -> for_statement .)
    SEMICOLON       reduce using rule 29 (statement -> for_statement .)
    ELSE            reduce using rule 29 (statement -> for_statement .)


state 26

    (30) statement -> procedure_call_statement .

    END             reduce using rule 30 (statement -> procedure_call_statement .)
    SEMICOLON       reduce using rule 30 (statement -> procedure_call_statement .)
    ELSE            reduce using rule 30 (statement -> procedure_call_statement .)


state 27

    (31) statement -> halt_statement .

    END             reduce using rule 31 (statement -> halt_statement .)
    SEMICOLON       reduce using rule 31 (statement -> halt_statement .)
    ELSE            reduce using rule 31 (statement -> halt_statement .)


state 28

    (32) statement -> empty .

    END             reduce using rule 32 (statement -> empty .)
    SEMICOLON       reduce using rule 32 (statement -> empty .)
    ELSE            reduce using rule 32 (statement -> empty .)


state 29

    (33) assignment_statement -> variable . ASSIGN expression

    ASSIGN          shift and go to state 44


state 30

    (36) if_statement -> IF . expression THEN statement
    (37) if_statement -> IF . expression THEN statement ELSE statement
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    expression                     shift and go to state 45
    simple_expression              shift and go to state 46
    variable                       shift and go to state 47
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 31

    (38) while_statement -> WHILE . expression DO statement
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    expression                     shift and go to state 59
    simple_expression              shift and go to state 46
    variable                       shift and go to state 47
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 32

    (39) for_statement -> FOR . ID ASSIGN expression TO expression DO statement
    (40) for_statement -> FOR . ID ASSIGN expression DOWNTO expression DO statement

    ID              shift and go to state 60


state 33

    (41) procedure_call_statement -> ID . LPAREN expression_list RPAREN
    (42) procedure_call_statement -> ID . LPAREN RPAREN
    (34) variable -> ID .
    (35) variable -> ID . LBRACKET expression RBRACKET

    LPAREN          shift and go to state 61
    ASSIGN          reduce using rule 34 (variable -> ID .)
    LBRACKET        shift and go to state 62


state 34

    (43) procedure_call_statement -> WRITELN . LPAREN expression_list RPAREN
    (44) procedure_call_statement -> WRITELN . LPAREN RPAREN

    LPAREN          shift and go to state 63


state 35

    (45) procedure_call_statement -> WRITE . LPAREN expression_list RPAREN
    (46) procedure_call_statement -> WRITE . LPAREN RPAREN

    LPAREN          shift and go to state 64


state 36

    (47) procedure_call_statement -> READLN . LPAREN variable RPAREN
    (48) procedure_call_statement -> READLN . LPAREN RPAREN

    LPAREN          shift and go to state 65


state 37

    (89) halt_statement -> HALT . SEMICOLON

    SEMICOLON       shift and go to state 66


state 38

    (10) var_declarations -> var_declarations var_declaration .

    ID              reduce using rule 10 (var_declarations -> var_declarations var_declaration .)
    BEGIN           reduce using rule 10 (var_declarations -> var_declarations var_declaration .)


state 39

    (12) var_declaration -> id_list COLON . type_spec SEMICOLON
    (15) type_spec -> . INTEGER_TYPE
    (16) type_spec -> . REAL_TYPE
    (17) type_spec -> . BOOLEAN
    (18) type_spec -> . STRING_TYPE
    (19) type_spec -> . CHAR_TYPE
    (20) type_spec -> . array_type
    (21) array_type -> . ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    INTEGER_TYPE    shift and go to state 68
    REAL_TYPE       shift and go to state 69
    BOOLEAN         shift and go to state 70
    STRING_TYPE     shift and go to state 71
    CHAR_TYPE       shift and go to state 72
    ARRAY           shift and go to state 74

    type_spec                      shift and go to state 67
    array_type                     shift and go to state 73

state 40

    (13) id_list -> id_list COMMA . ID

    ID              shift and go to state 75


state 41

    (85) function_declaration -> FUNCTION ID LPAREN . param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (86) param_list -> . param_list SEMICOLON param
    (87) param_list -> . param
    (88) param -> . id_list COLON type_spec
    (13) id_list -> . id_list COMMA ID
    (14) id_list -> . ID

    ID              shift and go to state 17

    param_list                     shift and go to state 76
    param                          shift and go to state 77
    id_list                        shift and go to state 78

state 42

    (22) compound_statement -> BEGIN statement_list END .

    PERIOD          reduce using rule 22 (compound_statement -> BEGIN statement_list END .)
    END             reduce using rule 22 (compound_statement -> BEGIN statement_list END .)
    SEMICOLON       reduce using rule 22 (compound_statement -> BEGIN statement_list END .)
    ELSE            reduce using rule 22 (compound_statement -> BEGIN statement_list END .)


state 43

    (23) statement_list -> statement_list SEMICOLON . statement
    (25) statement -> . compound_statement
    (26) statement -> . assignment_statement
    (27) statement -> . if_statement
    (28) statement -> . while_statement
    (29) statement -> . for_statement
    (30) statement -> . procedure_call_statement
    (31) statement -> . halt_statement
    (32) statement -> . empty
    (22) compound_statement -> . BEGIN statement_list END
    (33) assignment_statement -> . variable ASSIGN expression
    (36) if_statement -> . IF expression THEN statement
    (37) if_statement -> . IF expression THEN statement ELSE statement
    (38) while_statement -> . WHILE expression DO statement
    (39) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (40) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (41) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (42) procedure_call_statement -> . ID LPAREN RPAREN
    (43) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (44) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (45) procedure_call_statement -> . WRITE LPAREN expression_list RPAREN
    (46) procedure_call_statement -> . WRITE LPAREN RPAREN
    (47) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (48) procedure_call_statement -> . READLN LPAREN RPAREN
    (89) halt_statement -> . HALT SEMICOLON
    (90) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    BEGIN           shift and go to state 13
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32
    ID              shift and go to state 33
    WRITELN         shift and go to state 34
    WRITE           shift and go to state 35
    READLN          shift and go to state 36
    HALT            shift and go to state 37
    END             reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)

    statement                      shift and go to state 79
    compound_statement             shift and go to state 21
    assignment_statement           shift and go to state 22
    if_statement                   shift and go to state 23
    while_statement                shift and go to state 24
    for_statement                  shift and go to state 25
    procedure_call_statement       shift and go to state 26
    halt_statement                 shift and go to state 27
    empty                          shift and go to state 28
    variable                       shift and go to state 29

state 44

    (33) assignment_statement -> variable ASSIGN . expression
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    variable                       shift and go to state 47
    expression                     shift and go to state 80
    simple_expression              shift and go to state 46
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 45

    (36) if_statement -> IF expression . THEN statement
    (37) if_statement -> IF expression . THEN statement ELSE statement

    THEN            shift and go to state 81


state 46

    (51) expression -> simple_expression .
    (52) expression -> simple_expression . relop simple_expression
    (61) simple_expression -> simple_expression . addop term
    (53) relop -> . EQ
    (54) relop -> . NEQ
    (55) relop -> . LT
    (56) relop -> . LE
    (57) relop -> . GT
    (58) relop -> . GE
    (59) relop -> . IN
    (62) addop -> . PLUS
    (63) addop -> . MINUS
    (64) addop -> . OR

    THEN            reduce using rule 51 (expression -> simple_expression .)
    DO              reduce using rule 51 (expression -> simple_expression .)
    END             reduce using rule 51 (expression -> simple_expression .)
    SEMICOLON       reduce using rule 51 (expression -> simple_expression .)
    ELSE            reduce using rule 51 (expression -> simple_expression .)
    RPAREN          reduce using rule 51 (expression -> simple_expression .)
    COMMA           reduce using rule 51 (expression -> simple_expression .)
    RBRACKET        reduce using rule 51 (expression -> simple_expression .)
    TO              reduce using rule 51 (expression -> simple_expression .)
    DOWNTO          reduce using rule 51 (expression -> simple_expression .)
    EQ              shift and go to state 84
    NEQ             shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    IN              shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    OR              shift and go to state 93

    relop                          shift and go to state 82
    addop                          shift and go to state 83

state 47

    (81) expression -> variable . COLON INTEGER
    (82) expression -> variable . COLON INTEGER COLON INTEGER
    (72) factor -> variable .

    COLON           shift and go to state 94
    TIMES           reduce using rule 72 (factor -> variable .)
    DIVIDE          reduce using rule 72 (factor -> variable .)
    DIV             reduce using rule 72 (factor -> variable .)
    MOD             reduce using rule 72 (factor -> variable .)
    AND             reduce using rule 72 (factor -> variable .)
    EQ              reduce using rule 72 (factor -> variable .)
    NEQ             reduce using rule 72 (factor -> variable .)
    LT              reduce using rule 72 (factor -> variable .)
    LE              reduce using rule 72 (factor -> variable .)
    GT              reduce using rule 72 (factor -> variable .)
    GE              reduce using rule 72 (factor -> variable .)
    IN              reduce using rule 72 (factor -> variable .)
    PLUS            reduce using rule 72 (factor -> variable .)
    MINUS           reduce using rule 72 (factor -> variable .)
    OR              reduce using rule 72 (factor -> variable .)
    THEN            reduce using rule 72 (factor -> variable .)
    DO              reduce using rule 72 (factor -> variable .)
    END             reduce using rule 72 (factor -> variable .)
    SEMICOLON       reduce using rule 72 (factor -> variable .)
    ELSE            reduce using rule 72 (factor -> variable .)
    RPAREN          reduce using rule 72 (factor -> variable .)
    COMMA           reduce using rule 72 (factor -> variable .)
    RBRACKET        reduce using rule 72 (factor -> variable .)
    TO              reduce using rule 72 (factor -> variable .)
    DOWNTO          reduce using rule 72 (factor -> variable .)


state 48

    (73) factor -> INTEGER .

    TIMES           reduce using rule 73 (factor -> INTEGER .)
    DIVIDE          reduce using rule 73 (factor -> INTEGER .)
    DIV             reduce using rule 73 (factor -> INTEGER .)
    MOD             reduce using rule 73 (factor -> INTEGER .)
    AND             reduce using rule 73 (factor -> INTEGER .)
    EQ              reduce using rule 73 (factor -> INTEGER .)
    NEQ             reduce using rule 73 (factor -> INTEGER .)
    LT              reduce using rule 73 (factor -> INTEGER .)
    LE              reduce using rule 73 (factor -> INTEGER .)
    GT              reduce using rule 73 (factor -> INTEGER .)
    GE              reduce using rule 73 (factor -> INTEGER .)
    IN              reduce using rule 73 (factor -> INTEGER .)
    PLUS            reduce using rule 73 (factor -> INTEGER .)
    MINUS           reduce using rule 73 (factor -> INTEGER .)
    OR              reduce using rule 73 (factor -> INTEGER .)
    THEN            reduce using rule 73 (factor -> INTEGER .)
    DO              reduce using rule 73 (factor -> INTEGER .)
    END             reduce using rule 73 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 73 (factor -> INTEGER .)
    ELSE            reduce using rule 73 (factor -> INTEGER .)
    RPAREN          reduce using rule 73 (factor -> INTEGER .)
    COMMA           reduce using rule 73 (factor -> INTEGER .)
    RBRACKET        reduce using rule 73 (factor -> INTEGER .)
    TO              reduce using rule 73 (factor -> INTEGER .)
    DOWNTO          reduce using rule 73 (factor -> INTEGER .)


state 49

    (60) simple_expression -> term .
    (66) term -> term . mulop factor
    (67) mulop -> . TIMES
    (68) mulop -> . DIVIDE
    (69) mulop -> . DIV
    (70) mulop -> . MOD
    (71) mulop -> . AND

    EQ              reduce using rule 60 (simple_expression -> term .)
    NEQ             reduce using rule 60 (simple_expression -> term .)
    LT              reduce using rule 60 (simple_expression -> term .)
    LE              reduce using rule 60 (simple_expression -> term .)
    GT              reduce using rule 60 (simple_expression -> term .)
    GE              reduce using rule 60 (simple_expression -> term .)
    IN              reduce using rule 60 (simple_expression -> term .)
    PLUS            reduce using rule 60 (simple_expression -> term .)
    MINUS           reduce using rule 60 (simple_expression -> term .)
    OR              reduce using rule 60 (simple_expression -> term .)
    THEN            reduce using rule 60 (simple_expression -> term .)
    DO              reduce using rule 60 (simple_expression -> term .)
    END             reduce using rule 60 (simple_expression -> term .)
    SEMICOLON       reduce using rule 60 (simple_expression -> term .)
    ELSE            reduce using rule 60 (simple_expression -> term .)
    RPAREN          reduce using rule 60 (simple_expression -> term .)
    COMMA           reduce using rule 60 (simple_expression -> term .)
    RBRACKET        reduce using rule 60 (simple_expression -> term .)
    TO              reduce using rule 60 (simple_expression -> term .)
    DOWNTO          reduce using rule 60 (simple_expression -> term .)
    TIMES           shift and go to state 96
    DIVIDE          shift and go to state 97
    DIV             shift and go to state 98
    MOD             shift and go to state 99
    AND             shift and go to state 100

    mulop                          shift and go to state 95

state 50

    (34) variable -> ID .
    (35) variable -> ID . LBRACKET expression RBRACKET
    (83) function_call -> ID . LPAREN expression_list RPAREN
    (84) function_call -> ID . LPAREN RPAREN

    COLON           reduce using rule 34 (variable -> ID .)
    TIMES           reduce using rule 34 (variable -> ID .)
    DIVIDE          reduce using rule 34 (variable -> ID .)
    DIV             reduce using rule 34 (variable -> ID .)
    MOD             reduce using rule 34 (variable -> ID .)
    AND             reduce using rule 34 (variable -> ID .)
    EQ              reduce using rule 34 (variable -> ID .)
    NEQ             reduce using rule 34 (variable -> ID .)
    LT              reduce using rule 34 (variable -> ID .)
    LE              reduce using rule 34 (variable -> ID .)
    GT              reduce using rule 34 (variable -> ID .)
    GE              reduce using rule 34 (variable -> ID .)
    IN              reduce using rule 34 (variable -> ID .)
    PLUS            reduce using rule 34 (variable -> ID .)
    MINUS           reduce using rule 34 (variable -> ID .)
    OR              reduce using rule 34 (variable -> ID .)
    THEN            reduce using rule 34 (variable -> ID .)
    DO              reduce using rule 34 (variable -> ID .)
    END             reduce using rule 34 (variable -> ID .)
    SEMICOLON       reduce using rule 34 (variable -> ID .)
    ELSE            reduce using rule 34 (variable -> ID .)
    RPAREN          reduce using rule 34 (variable -> ID .)
    COMMA           reduce using rule 34 (variable -> ID .)
    RBRACKET        reduce using rule 34 (variable -> ID .)
    TO              reduce using rule 34 (variable -> ID .)
    DOWNTO          reduce using rule 34 (variable -> ID .)
    LBRACKET        shift and go to state 62
    LPAREN          shift and go to state 101


state 51

    (65) term -> factor .

    TIMES           reduce using rule 65 (term -> factor .)
    DIVIDE          reduce using rule 65 (term -> factor .)
    DIV             reduce using rule 65 (term -> factor .)
    MOD             reduce using rule 65 (term -> factor .)
    AND             reduce using rule 65 (term -> factor .)
    EQ              reduce using rule 65 (term -> factor .)
    NEQ             reduce using rule 65 (term -> factor .)
    LT              reduce using rule 65 (term -> factor .)
    LE              reduce using rule 65 (term -> factor .)
    GT              reduce using rule 65 (term -> factor .)
    GE              reduce using rule 65 (term -> factor .)
    IN              reduce using rule 65 (term -> factor .)
    PLUS            reduce using rule 65 (term -> factor .)
    MINUS           reduce using rule 65 (term -> factor .)
    OR              reduce using rule 65 (term -> factor .)
    THEN            reduce using rule 65 (term -> factor .)
    DO              reduce using rule 65 (term -> factor .)
    END             reduce using rule 65 (term -> factor .)
    SEMICOLON       reduce using rule 65 (term -> factor .)
    ELSE            reduce using rule 65 (term -> factor .)
    RPAREN          reduce using rule 65 (term -> factor .)
    COMMA           reduce using rule 65 (term -> factor .)
    RBRACKET        reduce using rule 65 (term -> factor .)
    TO              reduce using rule 65 (term -> factor .)
    DOWNTO          reduce using rule 65 (term -> factor .)


state 52

    (74) factor -> REAL .

    TIMES           reduce using rule 74 (factor -> REAL .)
    DIVIDE          reduce using rule 74 (factor -> REAL .)
    DIV             reduce using rule 74 (factor -> REAL .)
    MOD             reduce using rule 74 (factor -> REAL .)
    AND             reduce using rule 74 (factor -> REAL .)
    EQ              reduce using rule 74 (factor -> REAL .)
    NEQ             reduce using rule 74 (factor -> REAL .)
    LT              reduce using rule 74 (factor -> REAL .)
    LE              reduce using rule 74 (factor -> REAL .)
    GT              reduce using rule 74 (factor -> REAL .)
    GE              reduce using rule 74 (factor -> REAL .)
    IN              reduce using rule 74 (factor -> REAL .)
    PLUS            reduce using rule 74 (factor -> REAL .)
    MINUS           reduce using rule 74 (factor -> REAL .)
    OR              reduce using rule 74 (factor -> REAL .)
    THEN            reduce using rule 74 (factor -> REAL .)
    DO              reduce using rule 74 (factor -> REAL .)
    END             reduce using rule 74 (factor -> REAL .)
    SEMICOLON       reduce using rule 74 (factor -> REAL .)
    ELSE            reduce using rule 74 (factor -> REAL .)
    RPAREN          reduce using rule 74 (factor -> REAL .)
    COMMA           reduce using rule 74 (factor -> REAL .)
    RBRACKET        reduce using rule 74 (factor -> REAL .)
    TO              reduce using rule 74 (factor -> REAL .)
    DOWNTO          reduce using rule 74 (factor -> REAL .)


state 53

    (75) factor -> STRING .

    TIMES           reduce using rule 75 (factor -> STRING .)
    DIVIDE          reduce using rule 75 (factor -> STRING .)
    DIV             reduce using rule 75 (factor -> STRING .)
    MOD             reduce using rule 75 (factor -> STRING .)
    AND             reduce using rule 75 (factor -> STRING .)
    EQ              reduce using rule 75 (factor -> STRING .)
    NEQ             reduce using rule 75 (factor -> STRING .)
    LT              reduce using rule 75 (factor -> STRING .)
    LE              reduce using rule 75 (factor -> STRING .)
    GT              reduce using rule 75 (factor -> STRING .)
    GE              reduce using rule 75 (factor -> STRING .)
    IN              reduce using rule 75 (factor -> STRING .)
    PLUS            reduce using rule 75 (factor -> STRING .)
    MINUS           reduce using rule 75 (factor -> STRING .)
    OR              reduce using rule 75 (factor -> STRING .)
    THEN            reduce using rule 75 (factor -> STRING .)
    DO              reduce using rule 75 (factor -> STRING .)
    END             reduce using rule 75 (factor -> STRING .)
    SEMICOLON       reduce using rule 75 (factor -> STRING .)
    ELSE            reduce using rule 75 (factor -> STRING .)
    RPAREN          reduce using rule 75 (factor -> STRING .)
    COMMA           reduce using rule 75 (factor -> STRING .)
    RBRACKET        reduce using rule 75 (factor -> STRING .)
    TO              reduce using rule 75 (factor -> STRING .)
    DOWNTO          reduce using rule 75 (factor -> STRING .)


state 54

    (76) factor -> TRUE .

    TIMES           reduce using rule 76 (factor -> TRUE .)
    DIVIDE          reduce using rule 76 (factor -> TRUE .)
    DIV             reduce using rule 76 (factor -> TRUE .)
    MOD             reduce using rule 76 (factor -> TRUE .)
    AND             reduce using rule 76 (factor -> TRUE .)
    EQ              reduce using rule 76 (factor -> TRUE .)
    NEQ             reduce using rule 76 (factor -> TRUE .)
    LT              reduce using rule 76 (factor -> TRUE .)
    LE              reduce using rule 76 (factor -> TRUE .)
    GT              reduce using rule 76 (factor -> TRUE .)
    GE              reduce using rule 76 (factor -> TRUE .)
    IN              reduce using rule 76 (factor -> TRUE .)
    PLUS            reduce using rule 76 (factor -> TRUE .)
    MINUS           reduce using rule 76 (factor -> TRUE .)
    OR              reduce using rule 76 (factor -> TRUE .)
    THEN            reduce using rule 76 (factor -> TRUE .)
    DO              reduce using rule 76 (factor -> TRUE .)
    END             reduce using rule 76 (factor -> TRUE .)
    SEMICOLON       reduce using rule 76 (factor -> TRUE .)
    ELSE            reduce using rule 76 (factor -> TRUE .)
    RPAREN          reduce using rule 76 (factor -> TRUE .)
    COMMA           reduce using rule 76 (factor -> TRUE .)
    RBRACKET        reduce using rule 76 (factor -> TRUE .)
    TO              reduce using rule 76 (factor -> TRUE .)
    DOWNTO          reduce using rule 76 (factor -> TRUE .)


state 55

    (77) factor -> FALSE .

    TIMES           reduce using rule 77 (factor -> FALSE .)
    DIVIDE          reduce using rule 77 (factor -> FALSE .)
    DIV             reduce using rule 77 (factor -> FALSE .)
    MOD             reduce using rule 77 (factor -> FALSE .)
    AND             reduce using rule 77 (factor -> FALSE .)
    EQ              reduce using rule 77 (factor -> FALSE .)
    NEQ             reduce using rule 77 (factor -> FALSE .)
    LT              reduce using rule 77 (factor -> FALSE .)
    LE              reduce using rule 77 (factor -> FALSE .)
    GT              reduce using rule 77 (factor -> FALSE .)
    GE              reduce using rule 77 (factor -> FALSE .)
    IN              reduce using rule 77 (factor -> FALSE .)
    PLUS            reduce using rule 77 (factor -> FALSE .)
    MINUS           reduce using rule 77 (factor -> FALSE .)
    OR              reduce using rule 77 (factor -> FALSE .)
    THEN            reduce using rule 77 (factor -> FALSE .)
    DO              reduce using rule 77 (factor -> FALSE .)
    END             reduce using rule 77 (factor -> FALSE .)
    SEMICOLON       reduce using rule 77 (factor -> FALSE .)
    ELSE            reduce using rule 77 (factor -> FALSE .)
    RPAREN          reduce using rule 77 (factor -> FALSE .)
    COMMA           reduce using rule 77 (factor -> FALSE .)
    RBRACKET        reduce using rule 77 (factor -> FALSE .)
    TO              reduce using rule 77 (factor -> FALSE .)
    DOWNTO          reduce using rule 77 (factor -> FALSE .)


state 56

    (78) factor -> LPAREN . expression RPAREN
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    expression                     shift and go to state 102
    simple_expression              shift and go to state 46
    variable                       shift and go to state 47
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 57

    (79) factor -> NOT . factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57
    ID              shift and go to state 50

    factor                         shift and go to state 103
    variable                       shift and go to state 104
    function_call                  shift and go to state 58

state 58

    (80) factor -> function_call .

    TIMES           reduce using rule 80 (factor -> function_call .)
    DIVIDE          reduce using rule 80 (factor -> function_call .)
    DIV             reduce using rule 80 (factor -> function_call .)
    MOD             reduce using rule 80 (factor -> function_call .)
    AND             reduce using rule 80 (factor -> function_call .)
    EQ              reduce using rule 80 (factor -> function_call .)
    NEQ             reduce using rule 80 (factor -> function_call .)
    LT              reduce using rule 80 (factor -> function_call .)
    LE              reduce using rule 80 (factor -> function_call .)
    GT              reduce using rule 80 (factor -> function_call .)
    GE              reduce using rule 80 (factor -> function_call .)
    IN              reduce using rule 80 (factor -> function_call .)
    PLUS            reduce using rule 80 (factor -> function_call .)
    MINUS           reduce using rule 80 (factor -> function_call .)
    OR              reduce using rule 80 (factor -> function_call .)
    THEN            reduce using rule 80 (factor -> function_call .)
    DO              reduce using rule 80 (factor -> function_call .)
    END             reduce using rule 80 (factor -> function_call .)
    SEMICOLON       reduce using rule 80 (factor -> function_call .)
    ELSE            reduce using rule 80 (factor -> function_call .)
    RPAREN          reduce using rule 80 (factor -> function_call .)
    COMMA           reduce using rule 80 (factor -> function_call .)
    RBRACKET        reduce using rule 80 (factor -> function_call .)
    TO              reduce using rule 80 (factor -> function_call .)
    DOWNTO          reduce using rule 80 (factor -> function_call .)


state 59

    (38) while_statement -> WHILE expression . DO statement

    DO              shift and go to state 105


state 60

    (39) for_statement -> FOR ID . ASSIGN expression TO expression DO statement
    (40) for_statement -> FOR ID . ASSIGN expression DOWNTO expression DO statement

    ASSIGN          shift and go to state 106


state 61

    (41) procedure_call_statement -> ID LPAREN . expression_list RPAREN
    (42) procedure_call_statement -> ID LPAREN . RPAREN
    (49) expression_list -> . expression_list COMMA expression
    (50) expression_list -> . expression
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    RPAREN          shift and go to state 108
    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    expression_list                shift and go to state 107
    expression                     shift and go to state 109
    simple_expression              shift and go to state 46
    variable                       shift and go to state 47
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 62

    (35) variable -> ID LBRACKET . expression RBRACKET
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    expression                     shift and go to state 110
    simple_expression              shift and go to state 46
    variable                       shift and go to state 47
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 63

    (43) procedure_call_statement -> WRITELN LPAREN . expression_list RPAREN
    (44) procedure_call_statement -> WRITELN LPAREN . RPAREN
    (49) expression_list -> . expression_list COMMA expression
    (50) expression_list -> . expression
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    RPAREN          shift and go to state 112
    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    expression_list                shift and go to state 111
    expression                     shift and go to state 109
    simple_expression              shift and go to state 46
    variable                       shift and go to state 47
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 64

    (45) procedure_call_statement -> WRITE LPAREN . expression_list RPAREN
    (46) procedure_call_statement -> WRITE LPAREN . RPAREN
    (49) expression_list -> . expression_list COMMA expression
    (50) expression_list -> . expression
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    RPAREN          shift and go to state 114
    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    expression_list                shift and go to state 113
    expression                     shift and go to state 109
    simple_expression              shift and go to state 46
    variable                       shift and go to state 47
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 65

    (47) procedure_call_statement -> READLN LPAREN . variable RPAREN
    (48) procedure_call_statement -> READLN LPAREN . RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    RPAREN          shift and go to state 116
    ID              shift and go to state 117

    variable                       shift and go to state 115

state 66

    (89) halt_statement -> HALT SEMICOLON .

    END             reduce using rule 89 (halt_statement -> HALT SEMICOLON .)
    SEMICOLON       reduce using rule 89 (halt_statement -> HALT SEMICOLON .)
    ELSE            reduce using rule 89 (halt_statement -> HALT SEMICOLON .)


state 67

    (12) var_declaration -> id_list COLON type_spec . SEMICOLON

    SEMICOLON       shift and go to state 118


state 68

    (15) type_spec -> INTEGER_TYPE .

    SEMICOLON       reduce using rule 15 (type_spec -> INTEGER_TYPE .)
    RPAREN          reduce using rule 15 (type_spec -> INTEGER_TYPE .)


state 69

    (16) type_spec -> REAL_TYPE .

    SEMICOLON       reduce using rule 16 (type_spec -> REAL_TYPE .)
    RPAREN          reduce using rule 16 (type_spec -> REAL_TYPE .)


state 70

    (17) type_spec -> BOOLEAN .

    SEMICOLON       reduce using rule 17 (type_spec -> BOOLEAN .)
    RPAREN          reduce using rule 17 (type_spec -> BOOLEAN .)


state 71

    (18) type_spec -> STRING_TYPE .

    SEMICOLON       reduce using rule 18 (type_spec -> STRING_TYPE .)
    RPAREN          reduce using rule 18 (type_spec -> STRING_TYPE .)


state 72

    (19) type_spec -> CHAR_TYPE .

    SEMICOLON       reduce using rule 19 (type_spec -> CHAR_TYPE .)
    RPAREN          reduce using rule 19 (type_spec -> CHAR_TYPE .)


state 73

    (20) type_spec -> array_type .

    SEMICOLON       reduce using rule 20 (type_spec -> array_type .)
    RPAREN          reduce using rule 20 (type_spec -> array_type .)


state 74

    (21) array_type -> ARRAY . LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    LBRACKET        shift and go to state 119


state 75

    (13) id_list -> id_list COMMA ID .

    COLON           reduce using rule 13 (id_list -> id_list COMMA ID .)
    COMMA           reduce using rule 13 (id_list -> id_list COMMA ID .)


state 76

    (85) function_declaration -> FUNCTION ID LPAREN param_list . RPAREN COLON type_spec SEMICOLON function_block SEMICOLON
    (86) param_list -> param_list . SEMICOLON param

    RPAREN          shift and go to state 120
    SEMICOLON       shift and go to state 121


state 77

    (87) param_list -> param .

    RPAREN          reduce using rule 87 (param_list -> param .)
    SEMICOLON       reduce using rule 87 (param_list -> param .)


state 78

    (88) param -> id_list . COLON type_spec
    (13) id_list -> id_list . COMMA ID

    COLON           shift and go to state 122
    COMMA           shift and go to state 40


state 79

    (23) statement_list -> statement_list SEMICOLON statement .

    END             reduce using rule 23 (statement_list -> statement_list SEMICOLON statement .)
    SEMICOLON       reduce using rule 23 (statement_list -> statement_list SEMICOLON statement .)


state 80

    (33) assignment_statement -> variable ASSIGN expression .

    END             reduce using rule 33 (assignment_statement -> variable ASSIGN expression .)
    SEMICOLON       reduce using rule 33 (assignment_statement -> variable ASSIGN expression .)
    ELSE            reduce using rule 33 (assignment_statement -> variable ASSIGN expression .)


state 81

    (36) if_statement -> IF expression THEN . statement
    (37) if_statement -> IF expression THEN . statement ELSE statement
    (25) statement -> . compound_statement
    (26) statement -> . assignment_statement
    (27) statement -> . if_statement
    (28) statement -> . while_statement
    (29) statement -> . for_statement
    (30) statement -> . procedure_call_statement
    (31) statement -> . halt_statement
    (32) statement -> . empty
    (22) compound_statement -> . BEGIN statement_list END
    (33) assignment_statement -> . variable ASSIGN expression
    (36) if_statement -> . IF expression THEN statement
    (37) if_statement -> . IF expression THEN statement ELSE statement
    (38) while_statement -> . WHILE expression DO statement
    (39) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (40) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (41) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (42) procedure_call_statement -> . ID LPAREN RPAREN
    (43) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (44) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (45) procedure_call_statement -> . WRITE LPAREN expression_list RPAREN
    (46) procedure_call_statement -> . WRITE LPAREN RPAREN
    (47) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (48) procedure_call_statement -> . READLN LPAREN RPAREN
    (89) halt_statement -> . HALT SEMICOLON
    (90) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    BEGIN           shift and go to state 13
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32
    ID              shift and go to state 33
    WRITELN         shift and go to state 34
    WRITE           shift and go to state 35
    READLN          shift and go to state 36
    HALT            shift and go to state 37
    ELSE            reduce using rule 90 (empty -> .)
    END             reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)

    statement                      shift and go to state 123
    compound_statement             shift and go to state 21
    assignment_statement           shift and go to state 22
    if_statement                   shift and go to state 23
    while_statement                shift and go to state 24
    for_statement                  shift and go to state 25
    procedure_call_statement       shift and go to state 26
    halt_statement                 shift and go to state 27
    empty                          shift and go to state 28
    variable                       shift and go to state 29

state 82

    (52) expression -> simple_expression relop . simple_expression
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57
    ID              shift and go to state 50

    simple_expression              shift and go to state 124
    term                           shift and go to state 49
    factor                         shift and go to state 51
    variable                       shift and go to state 104
    function_call                  shift and go to state 58

state 83

    (61) simple_expression -> simple_expression addop . term
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57
    ID              shift and go to state 50

    term                           shift and go to state 125
    factor                         shift and go to state 51
    variable                       shift and go to state 104
    function_call                  shift and go to state 58

state 84

    (53) relop -> EQ .

    INTEGER         reduce using rule 53 (relop -> EQ .)
    REAL            reduce using rule 53 (relop -> EQ .)
    STRING          reduce using rule 53 (relop -> EQ .)
    TRUE            reduce using rule 53 (relop -> EQ .)
    FALSE           reduce using rule 53 (relop -> EQ .)
    LPAREN          reduce using rule 53 (relop -> EQ .)
    NOT             reduce using rule 53 (relop -> EQ .)
    ID              reduce using rule 53 (relop -> EQ .)


state 85

    (54) relop -> NEQ .

    INTEGER         reduce using rule 54 (relop -> NEQ .)
    REAL            reduce using rule 54 (relop -> NEQ .)
    STRING          reduce using rule 54 (relop -> NEQ .)
    TRUE            reduce using rule 54 (relop -> NEQ .)
    FALSE           reduce using rule 54 (relop -> NEQ .)
    LPAREN          reduce using rule 54 (relop -> NEQ .)
    NOT             reduce using rule 54 (relop -> NEQ .)
    ID              reduce using rule 54 (relop -> NEQ .)


state 86

    (55) relop -> LT .

    INTEGER         reduce using rule 55 (relop -> LT .)
    REAL            reduce using rule 55 (relop -> LT .)
    STRING          reduce using rule 55 (relop -> LT .)
    TRUE            reduce using rule 55 (relop -> LT .)
    FALSE           reduce using rule 55 (relop -> LT .)
    LPAREN          reduce using rule 55 (relop -> LT .)
    NOT             reduce using rule 55 (relop -> LT .)
    ID              reduce using rule 55 (relop -> LT .)


state 87

    (56) relop -> LE .

    INTEGER         reduce using rule 56 (relop -> LE .)
    REAL            reduce using rule 56 (relop -> LE .)
    STRING          reduce using rule 56 (relop -> LE .)
    TRUE            reduce using rule 56 (relop -> LE .)
    FALSE           reduce using rule 56 (relop -> LE .)
    LPAREN          reduce using rule 56 (relop -> LE .)
    NOT             reduce using rule 56 (relop -> LE .)
    ID              reduce using rule 56 (relop -> LE .)


state 88

    (57) relop -> GT .

    INTEGER         reduce using rule 57 (relop -> GT .)
    REAL            reduce using rule 57 (relop -> GT .)
    STRING          reduce using rule 57 (relop -> GT .)
    TRUE            reduce using rule 57 (relop -> GT .)
    FALSE           reduce using rule 57 (relop -> GT .)
    LPAREN          reduce using rule 57 (relop -> GT .)
    NOT             reduce using rule 57 (relop -> GT .)
    ID              reduce using rule 57 (relop -> GT .)


state 89

    (58) relop -> GE .

    INTEGER         reduce using rule 58 (relop -> GE .)
    REAL            reduce using rule 58 (relop -> GE .)
    STRING          reduce using rule 58 (relop -> GE .)
    TRUE            reduce using rule 58 (relop -> GE .)
    FALSE           reduce using rule 58 (relop -> GE .)
    LPAREN          reduce using rule 58 (relop -> GE .)
    NOT             reduce using rule 58 (relop -> GE .)
    ID              reduce using rule 58 (relop -> GE .)


state 90

    (59) relop -> IN .

    INTEGER         reduce using rule 59 (relop -> IN .)
    REAL            reduce using rule 59 (relop -> IN .)
    STRING          reduce using rule 59 (relop -> IN .)
    TRUE            reduce using rule 59 (relop -> IN .)
    FALSE           reduce using rule 59 (relop -> IN .)
    LPAREN          reduce using rule 59 (relop -> IN .)
    NOT             reduce using rule 59 (relop -> IN .)
    ID              reduce using rule 59 (relop -> IN .)


state 91

    (62) addop -> PLUS .

    INTEGER         reduce using rule 62 (addop -> PLUS .)
    REAL            reduce using rule 62 (addop -> PLUS .)
    STRING          reduce using rule 62 (addop -> PLUS .)
    TRUE            reduce using rule 62 (addop -> PLUS .)
    FALSE           reduce using rule 62 (addop -> PLUS .)
    LPAREN          reduce using rule 62 (addop -> PLUS .)
    NOT             reduce using rule 62 (addop -> PLUS .)
    ID              reduce using rule 62 (addop -> PLUS .)


state 92

    (63) addop -> MINUS .

    INTEGER         reduce using rule 63 (addop -> MINUS .)
    REAL            reduce using rule 63 (addop -> MINUS .)
    STRING          reduce using rule 63 (addop -> MINUS .)
    TRUE            reduce using rule 63 (addop -> MINUS .)
    FALSE           reduce using rule 63 (addop -> MINUS .)
    LPAREN          reduce using rule 63 (addop -> MINUS .)
    NOT             reduce using rule 63 (addop -> MINUS .)
    ID              reduce using rule 63 (addop -> MINUS .)


state 93

    (64) addop -> OR .

    INTEGER         reduce using rule 64 (addop -> OR .)
    REAL            reduce using rule 64 (addop -> OR .)
    STRING          reduce using rule 64 (addop -> OR .)
    TRUE            reduce using rule 64 (addop -> OR .)
    FALSE           reduce using rule 64 (addop -> OR .)
    LPAREN          reduce using rule 64 (addop -> OR .)
    NOT             reduce using rule 64 (addop -> OR .)
    ID              reduce using rule 64 (addop -> OR .)


state 94

    (81) expression -> variable COLON . INTEGER
    (82) expression -> variable COLON . INTEGER COLON INTEGER

    INTEGER         shift and go to state 126


state 95

    (66) term -> term mulop . factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57
    ID              shift and go to state 50

    factor                         shift and go to state 127
    variable                       shift and go to state 104
    function_call                  shift and go to state 58

state 96

    (67) mulop -> TIMES .

    INTEGER         reduce using rule 67 (mulop -> TIMES .)
    REAL            reduce using rule 67 (mulop -> TIMES .)
    STRING          reduce using rule 67 (mulop -> TIMES .)
    TRUE            reduce using rule 67 (mulop -> TIMES .)
    FALSE           reduce using rule 67 (mulop -> TIMES .)
    LPAREN          reduce using rule 67 (mulop -> TIMES .)
    NOT             reduce using rule 67 (mulop -> TIMES .)
    ID              reduce using rule 67 (mulop -> TIMES .)


state 97

    (68) mulop -> DIVIDE .

    INTEGER         reduce using rule 68 (mulop -> DIVIDE .)
    REAL            reduce using rule 68 (mulop -> DIVIDE .)
    STRING          reduce using rule 68 (mulop -> DIVIDE .)
    TRUE            reduce using rule 68 (mulop -> DIVIDE .)
    FALSE           reduce using rule 68 (mulop -> DIVIDE .)
    LPAREN          reduce using rule 68 (mulop -> DIVIDE .)
    NOT             reduce using rule 68 (mulop -> DIVIDE .)
    ID              reduce using rule 68 (mulop -> DIVIDE .)


state 98

    (69) mulop -> DIV .

    INTEGER         reduce using rule 69 (mulop -> DIV .)
    REAL            reduce using rule 69 (mulop -> DIV .)
    STRING          reduce using rule 69 (mulop -> DIV .)
    TRUE            reduce using rule 69 (mulop -> DIV .)
    FALSE           reduce using rule 69 (mulop -> DIV .)
    LPAREN          reduce using rule 69 (mulop -> DIV .)
    NOT             reduce using rule 69 (mulop -> DIV .)
    ID              reduce using rule 69 (mulop -> DIV .)


state 99

    (70) mulop -> MOD .

    INTEGER         reduce using rule 70 (mulop -> MOD .)
    REAL            reduce using rule 70 (mulop -> MOD .)
    STRING          reduce using rule 70 (mulop -> MOD .)
    TRUE            reduce using rule 70 (mulop -> MOD .)
    FALSE           reduce using rule 70 (mulop -> MOD .)
    LPAREN          reduce using rule 70 (mulop -> MOD .)
    NOT             reduce using rule 70 (mulop -> MOD .)
    ID              reduce using rule 70 (mulop -> MOD .)


state 100

    (71) mulop -> AND .

    INTEGER         reduce using rule 71 (mulop -> AND .)
    REAL            reduce using rule 71 (mulop -> AND .)
    STRING          reduce using rule 71 (mulop -> AND .)
    TRUE            reduce using rule 71 (mulop -> AND .)
    FALSE           reduce using rule 71 (mulop -> AND .)
    LPAREN          reduce using rule 71 (mulop -> AND .)
    NOT             reduce using rule 71 (mulop -> AND .)
    ID              reduce using rule 71 (mulop -> AND .)


state 101

    (83) function_call -> ID LPAREN . expression_list RPAREN
    (84) function_call -> ID LPAREN . RPAREN
    (49) expression_list -> . expression_list COMMA expression
    (50) expression_list -> . expression
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    RPAREN          shift and go to state 129
    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    expression_list                shift and go to state 128
    expression                     shift and go to state 109
    simple_expression              shift and go to state 46
    variable                       shift and go to state 47
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 102

    (78) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 130


state 103

    (79) factor -> NOT factor .

    TIMES           reduce using rule 79 (factor -> NOT factor .)
    DIVIDE          reduce using rule 79 (factor -> NOT factor .)
    DIV             reduce using rule 79 (factor -> NOT factor .)
    MOD             reduce using rule 79 (factor -> NOT factor .)
    AND             reduce using rule 79 (factor -> NOT factor .)
    EQ              reduce using rule 79 (factor -> NOT factor .)
    NEQ             reduce using rule 79 (factor -> NOT factor .)
    LT              reduce using rule 79 (factor -> NOT factor .)
    LE              reduce using rule 79 (factor -> NOT factor .)
    GT              reduce using rule 79 (factor -> NOT factor .)
    GE              reduce using rule 79 (factor -> NOT factor .)
    IN              reduce using rule 79 (factor -> NOT factor .)
    PLUS            reduce using rule 79 (factor -> NOT factor .)
    MINUS           reduce using rule 79 (factor -> NOT factor .)
    OR              reduce using rule 79 (factor -> NOT factor .)
    THEN            reduce using rule 79 (factor -> NOT factor .)
    DO              reduce using rule 79 (factor -> NOT factor .)
    END             reduce using rule 79 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 79 (factor -> NOT factor .)
    ELSE            reduce using rule 79 (factor -> NOT factor .)
    RPAREN          reduce using rule 79 (factor -> NOT factor .)
    COMMA           reduce using rule 79 (factor -> NOT factor .)
    RBRACKET        reduce using rule 79 (factor -> NOT factor .)
    TO              reduce using rule 79 (factor -> NOT factor .)
    DOWNTO          reduce using rule 79 (factor -> NOT factor .)


state 104

    (72) factor -> variable .

    TIMES           reduce using rule 72 (factor -> variable .)
    DIVIDE          reduce using rule 72 (factor -> variable .)
    DIV             reduce using rule 72 (factor -> variable .)
    MOD             reduce using rule 72 (factor -> variable .)
    AND             reduce using rule 72 (factor -> variable .)
    EQ              reduce using rule 72 (factor -> variable .)
    NEQ             reduce using rule 72 (factor -> variable .)
    LT              reduce using rule 72 (factor -> variable .)
    LE              reduce using rule 72 (factor -> variable .)
    GT              reduce using rule 72 (factor -> variable .)
    GE              reduce using rule 72 (factor -> variable .)
    IN              reduce using rule 72 (factor -> variable .)
    PLUS            reduce using rule 72 (factor -> variable .)
    MINUS           reduce using rule 72 (factor -> variable .)
    OR              reduce using rule 72 (factor -> variable .)
    THEN            reduce using rule 72 (factor -> variable .)
    DO              reduce using rule 72 (factor -> variable .)
    END             reduce using rule 72 (factor -> variable .)
    SEMICOLON       reduce using rule 72 (factor -> variable .)
    ELSE            reduce using rule 72 (factor -> variable .)
    RPAREN          reduce using rule 72 (factor -> variable .)
    COMMA           reduce using rule 72 (factor -> variable .)
    RBRACKET        reduce using rule 72 (factor -> variable .)
    TO              reduce using rule 72 (factor -> variable .)
    DOWNTO          reduce using rule 72 (factor -> variable .)


state 105

    (38) while_statement -> WHILE expression DO . statement
    (25) statement -> . compound_statement
    (26) statement -> . assignment_statement
    (27) statement -> . if_statement
    (28) statement -> . while_statement
    (29) statement -> . for_statement
    (30) statement -> . procedure_call_statement
    (31) statement -> . halt_statement
    (32) statement -> . empty
    (22) compound_statement -> . BEGIN statement_list END
    (33) assignment_statement -> . variable ASSIGN expression
    (36) if_statement -> . IF expression THEN statement
    (37) if_statement -> . IF expression THEN statement ELSE statement
    (38) while_statement -> . WHILE expression DO statement
    (39) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (40) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (41) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (42) procedure_call_statement -> . ID LPAREN RPAREN
    (43) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (44) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (45) procedure_call_statement -> . WRITE LPAREN expression_list RPAREN
    (46) procedure_call_statement -> . WRITE LPAREN RPAREN
    (47) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (48) procedure_call_statement -> . READLN LPAREN RPAREN
    (89) halt_statement -> . HALT SEMICOLON
    (90) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    BEGIN           shift and go to state 13
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32
    ID              shift and go to state 33
    WRITELN         shift and go to state 34
    WRITE           shift and go to state 35
    READLN          shift and go to state 36
    HALT            shift and go to state 37
    ELSE            reduce using rule 90 (empty -> .)
    END             reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)

    statement                      shift and go to state 131
    compound_statement             shift and go to state 21
    assignment_statement           shift and go to state 22
    if_statement                   shift and go to state 23
    while_statement                shift and go to state 24
    for_statement                  shift and go to state 25
    procedure_call_statement       shift and go to state 26
    halt_statement                 shift and go to state 27
    empty                          shift and go to state 28
    variable                       shift and go to state 29

state 106

    (39) for_statement -> FOR ID ASSIGN . expression TO expression DO statement
    (40) for_statement -> FOR ID ASSIGN . expression DOWNTO expression DO statement
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    expression                     shift and go to state 132
    simple_expression              shift and go to state 46
    variable                       shift and go to state 47
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 107

    (41) procedure_call_statement -> ID LPAREN expression_list . RPAREN
    (49) expression_list -> expression_list . COMMA expression

    RPAREN          shift and go to state 133
    COMMA           shift and go to state 134


state 108

    (42) procedure_call_statement -> ID LPAREN RPAREN .

    END             reduce using rule 42 (procedure_call_statement -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 42 (procedure_call_statement -> ID LPAREN RPAREN .)
    ELSE            reduce using rule 42 (procedure_call_statement -> ID LPAREN RPAREN .)


state 109

    (50) expression_list -> expression .

    RPAREN          reduce using rule 50 (expression_list -> expression .)
    COMMA           reduce using rule 50 (expression_list -> expression .)


state 110

    (35) variable -> ID LBRACKET expression . RBRACKET

    RBRACKET        shift and go to state 135


state 111

    (43) procedure_call_statement -> WRITELN LPAREN expression_list . RPAREN
    (49) expression_list -> expression_list . COMMA expression

    RPAREN          shift and go to state 136
    COMMA           shift and go to state 134


state 112

    (44) procedure_call_statement -> WRITELN LPAREN RPAREN .

    END             reduce using rule 44 (procedure_call_statement -> WRITELN LPAREN RPAREN .)
    SEMICOLON       reduce using rule 44 (procedure_call_statement -> WRITELN LPAREN RPAREN .)
    ELSE            reduce using rule 44 (procedure_call_statement -> WRITELN LPAREN RPAREN .)


state 113

    (45) procedure_call_statement -> WRITE LPAREN expression_list . RPAREN
    (49) expression_list -> expression_list . COMMA expression

    RPAREN          shift and go to state 137
    COMMA           shift and go to state 134


state 114

    (46) procedure_call_statement -> WRITE LPAREN RPAREN .

    END             reduce using rule 46 (procedure_call_statement -> WRITE LPAREN RPAREN .)
    SEMICOLON       reduce using rule 46 (procedure_call_statement -> WRITE LPAREN RPAREN .)
    ELSE            reduce using rule 46 (procedure_call_statement -> WRITE LPAREN RPAREN .)


state 115

    (47) procedure_call_statement -> READLN LPAREN variable . RPAREN

    RPAREN          shift and go to state 138


state 116

    (48) procedure_call_statement -> READLN LPAREN RPAREN .

    END             reduce using rule 48 (procedure_call_statement -> READLN LPAREN RPAREN .)
    SEMICOLON       reduce using rule 48 (procedure_call_statement -> READLN LPAREN RPAREN .)
    ELSE            reduce using rule 48 (procedure_call_statement -> READLN LPAREN RPAREN .)


state 117

    (34) variable -> ID .
    (35) variable -> ID . LBRACKET expression RBRACKET

    RPAREN          reduce using rule 34 (variable -> ID .)
    LBRACKET        shift and go to state 62


state 118

    (12) var_declaration -> id_list COLON type_spec SEMICOLON .

    ID              reduce using rule 12 (var_declaration -> id_list COLON type_spec SEMICOLON .)
    BEGIN           reduce using rule 12 (var_declaration -> id_list COLON type_spec SEMICOLON .)


state 119

    (21) array_type -> ARRAY LBRACKET . INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    INTEGER         shift and go to state 139


state 120

    (85) function_declaration -> FUNCTION ID LPAREN param_list RPAREN . COLON type_spec SEMICOLON function_block SEMICOLON

    COLON           shift and go to state 140


state 121

    (86) param_list -> param_list SEMICOLON . param
    (88) param -> . id_list COLON type_spec
    (13) id_list -> . id_list COMMA ID
    (14) id_list -> . ID

    ID              shift and go to state 17

    param                          shift and go to state 141
    id_list                        shift and go to state 78

state 122

    (88) param -> id_list COLON . type_spec
    (15) type_spec -> . INTEGER_TYPE
    (16) type_spec -> . REAL_TYPE
    (17) type_spec -> . BOOLEAN
    (18) type_spec -> . STRING_TYPE
    (19) type_spec -> . CHAR_TYPE
    (20) type_spec -> . array_type
    (21) array_type -> . ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    INTEGER_TYPE    shift and go to state 68
    REAL_TYPE       shift and go to state 69
    BOOLEAN         shift and go to state 70
    STRING_TYPE     shift and go to state 71
    CHAR_TYPE       shift and go to state 72
    ARRAY           shift and go to state 74

    type_spec                      shift and go to state 142
    array_type                     shift and go to state 73

state 123

    (36) if_statement -> IF expression THEN statement .
    (37) if_statement -> IF expression THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    END             reduce using rule 36 (if_statement -> IF expression THEN statement .)
    SEMICOLON       reduce using rule 36 (if_statement -> IF expression THEN statement .)
    ELSE            shift and go to state 143

  ! ELSE            [ reduce using rule 36 (if_statement -> IF expression THEN statement .) ]


state 124

    (52) expression -> simple_expression relop simple_expression .
    (61) simple_expression -> simple_expression . addop term
    (62) addop -> . PLUS
    (63) addop -> . MINUS
    (64) addop -> . OR

    THEN            reduce using rule 52 (expression -> simple_expression relop simple_expression .)
    DO              reduce using rule 52 (expression -> simple_expression relop simple_expression .)
    END             reduce using rule 52 (expression -> simple_expression relop simple_expression .)
    SEMICOLON       reduce using rule 52 (expression -> simple_expression relop simple_expression .)
    ELSE            reduce using rule 52 (expression -> simple_expression relop simple_expression .)
    RPAREN          reduce using rule 52 (expression -> simple_expression relop simple_expression .)
    COMMA           reduce using rule 52 (expression -> simple_expression relop simple_expression .)
    RBRACKET        reduce using rule 52 (expression -> simple_expression relop simple_expression .)
    TO              reduce using rule 52 (expression -> simple_expression relop simple_expression .)
    DOWNTO          reduce using rule 52 (expression -> simple_expression relop simple_expression .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    OR              shift and go to state 93

    addop                          shift and go to state 83

state 125

    (61) simple_expression -> simple_expression addop term .
    (66) term -> term . mulop factor
    (67) mulop -> . TIMES
    (68) mulop -> . DIVIDE
    (69) mulop -> . DIV
    (70) mulop -> . MOD
    (71) mulop -> . AND

    EQ              reduce using rule 61 (simple_expression -> simple_expression addop term .)
    NEQ             reduce using rule 61 (simple_expression -> simple_expression addop term .)
    LT              reduce using rule 61 (simple_expression -> simple_expression addop term .)
    LE              reduce using rule 61 (simple_expression -> simple_expression addop term .)
    GT              reduce using rule 61 (simple_expression -> simple_expression addop term .)
    GE              reduce using rule 61 (simple_expression -> simple_expression addop term .)
    IN              reduce using rule 61 (simple_expression -> simple_expression addop term .)
    PLUS            reduce using rule 61 (simple_expression -> simple_expression addop term .)
    MINUS           reduce using rule 61 (simple_expression -> simple_expression addop term .)
    OR              reduce using rule 61 (simple_expression -> simple_expression addop term .)
    THEN            reduce using rule 61 (simple_expression -> simple_expression addop term .)
    DO              reduce using rule 61 (simple_expression -> simple_expression addop term .)
    END             reduce using rule 61 (simple_expression -> simple_expression addop term .)
    SEMICOLON       reduce using rule 61 (simple_expression -> simple_expression addop term .)
    ELSE            reduce using rule 61 (simple_expression -> simple_expression addop term .)
    RPAREN          reduce using rule 61 (simple_expression -> simple_expression addop term .)
    COMMA           reduce using rule 61 (simple_expression -> simple_expression addop term .)
    RBRACKET        reduce using rule 61 (simple_expression -> simple_expression addop term .)
    TO              reduce using rule 61 (simple_expression -> simple_expression addop term .)
    DOWNTO          reduce using rule 61 (simple_expression -> simple_expression addop term .)
    TIMES           shift and go to state 96
    DIVIDE          shift and go to state 97
    DIV             shift and go to state 98
    MOD             shift and go to state 99
    AND             shift and go to state 100

    mulop                          shift and go to state 95

state 126

    (81) expression -> variable COLON INTEGER .
    (82) expression -> variable COLON INTEGER . COLON INTEGER

    THEN            reduce using rule 81 (expression -> variable COLON INTEGER .)
    DO              reduce using rule 81 (expression -> variable COLON INTEGER .)
    END             reduce using rule 81 (expression -> variable COLON INTEGER .)
    SEMICOLON       reduce using rule 81 (expression -> variable COLON INTEGER .)
    ELSE            reduce using rule 81 (expression -> variable COLON INTEGER .)
    RPAREN          reduce using rule 81 (expression -> variable COLON INTEGER .)
    COMMA           reduce using rule 81 (expression -> variable COLON INTEGER .)
    RBRACKET        reduce using rule 81 (expression -> variable COLON INTEGER .)
    TO              reduce using rule 81 (expression -> variable COLON INTEGER .)
    DOWNTO          reduce using rule 81 (expression -> variable COLON INTEGER .)
    COLON           shift and go to state 144


state 127

    (66) term -> term mulop factor .

    TIMES           reduce using rule 66 (term -> term mulop factor .)
    DIVIDE          reduce using rule 66 (term -> term mulop factor .)
    DIV             reduce using rule 66 (term -> term mulop factor .)
    MOD             reduce using rule 66 (term -> term mulop factor .)
    AND             reduce using rule 66 (term -> term mulop factor .)
    EQ              reduce using rule 66 (term -> term mulop factor .)
    NEQ             reduce using rule 66 (term -> term mulop factor .)
    LT              reduce using rule 66 (term -> term mulop factor .)
    LE              reduce using rule 66 (term -> term mulop factor .)
    GT              reduce using rule 66 (term -> term mulop factor .)
    GE              reduce using rule 66 (term -> term mulop factor .)
    IN              reduce using rule 66 (term -> term mulop factor .)
    PLUS            reduce using rule 66 (term -> term mulop factor .)
    MINUS           reduce using rule 66 (term -> term mulop factor .)
    OR              reduce using rule 66 (term -> term mulop factor .)
    THEN            reduce using rule 66 (term -> term mulop factor .)
    DO              reduce using rule 66 (term -> term mulop factor .)
    END             reduce using rule 66 (term -> term mulop factor .)
    SEMICOLON       reduce using rule 66 (term -> term mulop factor .)
    ELSE            reduce using rule 66 (term -> term mulop factor .)
    RPAREN          reduce using rule 66 (term -> term mulop factor .)
    COMMA           reduce using rule 66 (term -> term mulop factor .)
    RBRACKET        reduce using rule 66 (term -> term mulop factor .)
    TO              reduce using rule 66 (term -> term mulop factor .)
    DOWNTO          reduce using rule 66 (term -> term mulop factor .)


state 128

    (83) function_call -> ID LPAREN expression_list . RPAREN
    (49) expression_list -> expression_list . COMMA expression

    RPAREN          shift and go to state 145
    COMMA           shift and go to state 134


state 129

    (84) function_call -> ID LPAREN RPAREN .

    TIMES           reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    DIV             reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    MOD             reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    AND             reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    EQ              reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    NEQ             reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    LT              reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    LE              reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    GT              reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    GE              reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    IN              reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    OR              reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    THEN            reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    DO              reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    END             reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    ELSE            reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    TO              reduce using rule 84 (function_call -> ID LPAREN RPAREN .)
    DOWNTO          reduce using rule 84 (function_call -> ID LPAREN RPAREN .)


state 130

    (78) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    DIV             reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    MOD             reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    EQ              reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    LE              reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    GE              reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    IN              reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    THEN            reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    DO              reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    TO              reduce using rule 78 (factor -> LPAREN expression RPAREN .)
    DOWNTO          reduce using rule 78 (factor -> LPAREN expression RPAREN .)


state 131

    (38) while_statement -> WHILE expression DO statement .

    END             reduce using rule 38 (while_statement -> WHILE expression DO statement .)
    SEMICOLON       reduce using rule 38 (while_statement -> WHILE expression DO statement .)
    ELSE            reduce using rule 38 (while_statement -> WHILE expression DO statement .)


state 132

    (39) for_statement -> FOR ID ASSIGN expression . TO expression DO statement
    (40) for_statement -> FOR ID ASSIGN expression . DOWNTO expression DO statement

    TO              shift and go to state 146
    DOWNTO          shift and go to state 147


state 133

    (41) procedure_call_statement -> ID LPAREN expression_list RPAREN .

    END             reduce using rule 41 (procedure_call_statement -> ID LPAREN expression_list RPAREN .)
    SEMICOLON       reduce using rule 41 (procedure_call_statement -> ID LPAREN expression_list RPAREN .)
    ELSE            reduce using rule 41 (procedure_call_statement -> ID LPAREN expression_list RPAREN .)


state 134

    (49) expression_list -> expression_list COMMA . expression
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    expression                     shift and go to state 148
    simple_expression              shift and go to state 46
    variable                       shift and go to state 47
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 135

    (35) variable -> ID LBRACKET expression RBRACKET .

    ASSIGN          reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    COLON           reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    DIV             reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    MOD             reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    AND             reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    EQ              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    LT              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    LE              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    GT              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    GE              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    IN              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    OR              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    THEN            reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    DO              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    END             reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    TO              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    DOWNTO          reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)


state 136

    (43) procedure_call_statement -> WRITELN LPAREN expression_list RPAREN .

    END             reduce using rule 43 (procedure_call_statement -> WRITELN LPAREN expression_list RPAREN .)
    SEMICOLON       reduce using rule 43 (procedure_call_statement -> WRITELN LPAREN expression_list RPAREN .)
    ELSE            reduce using rule 43 (procedure_call_statement -> WRITELN LPAREN expression_list RPAREN .)


state 137

    (45) procedure_call_statement -> WRITE LPAREN expression_list RPAREN .

    END             reduce using rule 45 (procedure_call_statement -> WRITE LPAREN expression_list RPAREN .)
    SEMICOLON       reduce using rule 45 (procedure_call_statement -> WRITE LPAREN expression_list RPAREN .)
    ELSE            reduce using rule 45 (procedure_call_statement -> WRITE LPAREN expression_list RPAREN .)


state 138

    (47) procedure_call_statement -> READLN LPAREN variable RPAREN .

    END             reduce using rule 47 (procedure_call_statement -> READLN LPAREN variable RPAREN .)
    SEMICOLON       reduce using rule 47 (procedure_call_statement -> READLN LPAREN variable RPAREN .)
    ELSE            reduce using rule 47 (procedure_call_statement -> READLN LPAREN variable RPAREN .)


state 139

    (21) array_type -> ARRAY LBRACKET INTEGER . PERIOD PERIOD INTEGER RBRACKET OF type_spec

    PERIOD          shift and go to state 149


state 140

    (85) function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON . type_spec SEMICOLON function_block SEMICOLON
    (15) type_spec -> . INTEGER_TYPE
    (16) type_spec -> . REAL_TYPE
    (17) type_spec -> . BOOLEAN
    (18) type_spec -> . STRING_TYPE
    (19) type_spec -> . CHAR_TYPE
    (20) type_spec -> . array_type
    (21) array_type -> . ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    INTEGER_TYPE    shift and go to state 68
    REAL_TYPE       shift and go to state 69
    BOOLEAN         shift and go to state 70
    STRING_TYPE     shift and go to state 71
    CHAR_TYPE       shift and go to state 72
    ARRAY           shift and go to state 74

    type_spec                      shift and go to state 150
    array_type                     shift and go to state 73

state 141

    (86) param_list -> param_list SEMICOLON param .

    RPAREN          reduce using rule 86 (param_list -> param_list SEMICOLON param .)
    SEMICOLON       reduce using rule 86 (param_list -> param_list SEMICOLON param .)


state 142

    (88) param -> id_list COLON type_spec .

    RPAREN          reduce using rule 88 (param -> id_list COLON type_spec .)
    SEMICOLON       reduce using rule 88 (param -> id_list COLON type_spec .)


state 143

    (37) if_statement -> IF expression THEN statement ELSE . statement
    (25) statement -> . compound_statement
    (26) statement -> . assignment_statement
    (27) statement -> . if_statement
    (28) statement -> . while_statement
    (29) statement -> . for_statement
    (30) statement -> . procedure_call_statement
    (31) statement -> . halt_statement
    (32) statement -> . empty
    (22) compound_statement -> . BEGIN statement_list END
    (33) assignment_statement -> . variable ASSIGN expression
    (36) if_statement -> . IF expression THEN statement
    (37) if_statement -> . IF expression THEN statement ELSE statement
    (38) while_statement -> . WHILE expression DO statement
    (39) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (40) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (41) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (42) procedure_call_statement -> . ID LPAREN RPAREN
    (43) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (44) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (45) procedure_call_statement -> . WRITE LPAREN expression_list RPAREN
    (46) procedure_call_statement -> . WRITE LPAREN RPAREN
    (47) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (48) procedure_call_statement -> . READLN LPAREN RPAREN
    (89) halt_statement -> . HALT SEMICOLON
    (90) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    BEGIN           shift and go to state 13
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32
    ID              shift and go to state 33
    WRITELN         shift and go to state 34
    WRITE           shift and go to state 35
    READLN          shift and go to state 36
    HALT            shift and go to state 37
    ELSE            reduce using rule 90 (empty -> .)
    END             reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)

    statement                      shift and go to state 151
    compound_statement             shift and go to state 21
    assignment_statement           shift and go to state 22
    if_statement                   shift and go to state 23
    while_statement                shift and go to state 24
    for_statement                  shift and go to state 25
    procedure_call_statement       shift and go to state 26
    halt_statement                 shift and go to state 27
    empty                          shift and go to state 28
    variable                       shift and go to state 29

state 144

    (82) expression -> variable COLON INTEGER COLON . INTEGER

    INTEGER         shift and go to state 152


state 145

    (83) function_call -> ID LPAREN expression_list RPAREN .

    TIMES           reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    DIVIDE          reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    DIV             reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    MOD             reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    AND             reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    EQ              reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    NEQ             reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    LT              reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    LE              reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    GT              reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    GE              reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    IN              reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    PLUS            reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    MINUS           reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    OR              reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    THEN            reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    DO              reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    END             reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    SEMICOLON       reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    ELSE            reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    RPAREN          reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    COMMA           reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    RBRACKET        reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    TO              reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)
    DOWNTO          reduce using rule 83 (function_call -> ID LPAREN expression_list RPAREN .)


state 146

    (39) for_statement -> FOR ID ASSIGN expression TO . expression DO statement
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    expression                     shift and go to state 153
    simple_expression              shift and go to state 46
    variable                       shift and go to state 47
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 147

    (40) for_statement -> FOR ID ASSIGN expression DOWNTO . expression DO statement
    (51) expression -> . simple_expression
    (52) expression -> . simple_expression relop simple_expression
    (81) expression -> . variable COLON INTEGER
    (82) expression -> . variable COLON INTEGER COLON INTEGER
    (60) simple_expression -> . term
    (61) simple_expression -> . simple_expression addop term
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET
    (65) term -> . factor
    (66) term -> . term mulop factor
    (72) factor -> . variable
    (73) factor -> . INTEGER
    (74) factor -> . REAL
    (75) factor -> . STRING
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (78) factor -> . LPAREN expression RPAREN
    (79) factor -> . NOT factor
    (80) factor -> . function_call
    (83) function_call -> . ID LPAREN expression_list RPAREN
    (84) function_call -> . ID LPAREN RPAREN

    ID              shift and go to state 50
    INTEGER         shift and go to state 48
    REAL            shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56
    NOT             shift and go to state 57

    expression                     shift and go to state 154
    simple_expression              shift and go to state 46
    variable                       shift and go to state 47
    term                           shift and go to state 49
    factor                         shift and go to state 51
    function_call                  shift and go to state 58

state 148

    (49) expression_list -> expression_list COMMA expression .

    RPAREN          reduce using rule 49 (expression_list -> expression_list COMMA expression .)
    COMMA           reduce using rule 49 (expression_list -> expression_list COMMA expression .)


state 149

    (21) array_type -> ARRAY LBRACKET INTEGER PERIOD . PERIOD INTEGER RBRACKET OF type_spec

    PERIOD          shift and go to state 155


state 150

    (85) function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec . SEMICOLON function_block SEMICOLON

    SEMICOLON       shift and go to state 156


state 151

    (37) if_statement -> IF expression THEN statement ELSE statement .

    END             reduce using rule 37 (if_statement -> IF expression THEN statement ELSE statement .)
    SEMICOLON       reduce using rule 37 (if_statement -> IF expression THEN statement ELSE statement .)
    ELSE            reduce using rule 37 (if_statement -> IF expression THEN statement ELSE statement .)


state 152

    (82) expression -> variable COLON INTEGER COLON INTEGER .

    THEN            reduce using rule 82 (expression -> variable COLON INTEGER COLON INTEGER .)
    DO              reduce using rule 82 (expression -> variable COLON INTEGER COLON INTEGER .)
    END             reduce using rule 82 (expression -> variable COLON INTEGER COLON INTEGER .)
    SEMICOLON       reduce using rule 82 (expression -> variable COLON INTEGER COLON INTEGER .)
    ELSE            reduce using rule 82 (expression -> variable COLON INTEGER COLON INTEGER .)
    RPAREN          reduce using rule 82 (expression -> variable COLON INTEGER COLON INTEGER .)
    COMMA           reduce using rule 82 (expression -> variable COLON INTEGER COLON INTEGER .)
    RBRACKET        reduce using rule 82 (expression -> variable COLON INTEGER COLON INTEGER .)
    TO              reduce using rule 82 (expression -> variable COLON INTEGER COLON INTEGER .)
    DOWNTO          reduce using rule 82 (expression -> variable COLON INTEGER COLON INTEGER .)


state 153

    (39) for_statement -> FOR ID ASSIGN expression TO expression . DO statement

    DO              shift and go to state 157


state 154

    (40) for_statement -> FOR ID ASSIGN expression DOWNTO expression . DO statement

    DO              shift and go to state 158


state 155

    (21) array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD . INTEGER RBRACKET OF type_spec

    INTEGER         shift and go to state 159


state 156

    (85) function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON . function_block SEMICOLON
    (6) function_block -> . VAR var_declarations compound_statement
    (7) function_block -> . compound_statement
    (22) compound_statement -> . BEGIN statement_list END

    VAR             shift and go to state 161
    BEGIN           shift and go to state 13

    function_block                 shift and go to state 160
    compound_statement             shift and go to state 162

state 157

    (39) for_statement -> FOR ID ASSIGN expression TO expression DO . statement
    (25) statement -> . compound_statement
    (26) statement -> . assignment_statement
    (27) statement -> . if_statement
    (28) statement -> . while_statement
    (29) statement -> . for_statement
    (30) statement -> . procedure_call_statement
    (31) statement -> . halt_statement
    (32) statement -> . empty
    (22) compound_statement -> . BEGIN statement_list END
    (33) assignment_statement -> . variable ASSIGN expression
    (36) if_statement -> . IF expression THEN statement
    (37) if_statement -> . IF expression THEN statement ELSE statement
    (38) while_statement -> . WHILE expression DO statement
    (39) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (40) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (41) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (42) procedure_call_statement -> . ID LPAREN RPAREN
    (43) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (44) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (45) procedure_call_statement -> . WRITE LPAREN expression_list RPAREN
    (46) procedure_call_statement -> . WRITE LPAREN RPAREN
    (47) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (48) procedure_call_statement -> . READLN LPAREN RPAREN
    (89) halt_statement -> . HALT SEMICOLON
    (90) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    BEGIN           shift and go to state 13
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32
    ID              shift and go to state 33
    WRITELN         shift and go to state 34
    WRITE           shift and go to state 35
    READLN          shift and go to state 36
    HALT            shift and go to state 37
    ELSE            reduce using rule 90 (empty -> .)
    END             reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)

    statement                      shift and go to state 163
    compound_statement             shift and go to state 21
    assignment_statement           shift and go to state 22
    if_statement                   shift and go to state 23
    while_statement                shift and go to state 24
    for_statement                  shift and go to state 25
    procedure_call_statement       shift and go to state 26
    halt_statement                 shift and go to state 27
    empty                          shift and go to state 28
    variable                       shift and go to state 29

state 158

    (40) for_statement -> FOR ID ASSIGN expression DOWNTO expression DO . statement
    (25) statement -> . compound_statement
    (26) statement -> . assignment_statement
    (27) statement -> . if_statement
    (28) statement -> . while_statement
    (29) statement -> . for_statement
    (30) statement -> . procedure_call_statement
    (31) statement -> . halt_statement
    (32) statement -> . empty
    (22) compound_statement -> . BEGIN statement_list END
    (33) assignment_statement -> . variable ASSIGN expression
    (36) if_statement -> . IF expression THEN statement
    (37) if_statement -> . IF expression THEN statement ELSE statement
    (38) while_statement -> . WHILE expression DO statement
    (39) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (40) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (41) procedure_call_statement -> . ID LPAREN expression_list RPAREN
    (42) procedure_call_statement -> . ID LPAREN RPAREN
    (43) procedure_call_statement -> . WRITELN LPAREN expression_list RPAREN
    (44) procedure_call_statement -> . WRITELN LPAREN RPAREN
    (45) procedure_call_statement -> . WRITE LPAREN expression_list RPAREN
    (46) procedure_call_statement -> . WRITE LPAREN RPAREN
    (47) procedure_call_statement -> . READLN LPAREN variable RPAREN
    (48) procedure_call_statement -> . READLN LPAREN RPAREN
    (89) halt_statement -> . HALT SEMICOLON
    (90) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    BEGIN           shift and go to state 13
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32
    ID              shift and go to state 33
    WRITELN         shift and go to state 34
    WRITE           shift and go to state 35
    READLN          shift and go to state 36
    HALT            shift and go to state 37
    ELSE            reduce using rule 90 (empty -> .)
    END             reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)

    statement                      shift and go to state 164
    compound_statement             shift and go to state 21
    assignment_statement           shift and go to state 22
    if_statement                   shift and go to state 23
    while_statement                shift and go to state 24
    for_statement                  shift and go to state 25
    procedure_call_statement       shift and go to state 26
    halt_statement                 shift and go to state 27
    empty                          shift and go to state 28
    variable                       shift and go to state 29

state 159

    (21) array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER . RBRACKET OF type_spec

    RBRACKET        shift and go to state 165


state 160

    (85) function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block . SEMICOLON

    SEMICOLON       shift and go to state 166


state 161

    (6) function_block -> VAR . var_declarations compound_statement
    (10) var_declarations -> . var_declarations var_declaration
    (11) var_declarations -> . var_declaration
    (12) var_declaration -> . id_list COLON type_spec SEMICOLON
    (13) id_list -> . id_list COMMA ID
    (14) id_list -> . ID

    ID              shift and go to state 17

    var_declarations               shift and go to state 167
    var_declaration                shift and go to state 15
    id_list                        shift and go to state 16

state 162

    (7) function_block -> compound_statement .

    SEMICOLON       reduce using rule 7 (function_block -> compound_statement .)


state 163

    (39) for_statement -> FOR ID ASSIGN expression TO expression DO statement .

    END             reduce using rule 39 (for_statement -> FOR ID ASSIGN expression TO expression DO statement .)
    SEMICOLON       reduce using rule 39 (for_statement -> FOR ID ASSIGN expression TO expression DO statement .)
    ELSE            reduce using rule 39 (for_statement -> FOR ID ASSIGN expression TO expression DO statement .)


state 164

    (40) for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement .

    END             reduce using rule 40 (for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    SEMICOLON       reduce using rule 40 (for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    ELSE            reduce using rule 40 (for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement .)


state 165

    (21) array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET . OF type_spec

    OF              shift and go to state 168


state 166

    (85) function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON .

    BEGIN           reduce using rule 85 (function_declaration -> FUNCTION ID LPAREN param_list RPAREN COLON type_spec SEMICOLON function_block SEMICOLON .)


state 167

    (6) function_block -> VAR var_declarations . compound_statement
    (10) var_declarations -> var_declarations . var_declaration
    (22) compound_statement -> . BEGIN statement_list END
    (12) var_declaration -> . id_list COLON type_spec SEMICOLON
    (13) id_list -> . id_list COMMA ID
    (14) id_list -> . ID

    BEGIN           shift and go to state 13
    ID              shift and go to state 17

    compound_statement             shift and go to state 169
    var_declaration                shift and go to state 38
    id_list                        shift and go to state 16

state 168

    (21) array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF . type_spec
    (15) type_spec -> . INTEGER_TYPE
    (16) type_spec -> . REAL_TYPE
    (17) type_spec -> . BOOLEAN
    (18) type_spec -> . STRING_TYPE
    (19) type_spec -> . CHAR_TYPE
    (20) type_spec -> . array_type
    (21) array_type -> . ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec

    INTEGER_TYPE    shift and go to state 68
    REAL_TYPE       shift and go to state 69
    BOOLEAN         shift and go to state 70
    STRING_TYPE     shift and go to state 71
    CHAR_TYPE       shift and go to state 72
    ARRAY           shift and go to state 74

    type_spec                      shift and go to state 170
    array_type                     shift and go to state 73

state 169

    (6) function_block -> VAR var_declarations compound_statement .

    SEMICOLON       reduce using rule 6 (function_block -> VAR var_declarations compound_statement .)


state 170

    (21) array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec .

    SEMICOLON       reduce using rule 21 (array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec .)
    RPAREN          reduce using rule 21 (array_type -> ARRAY LBRACKET INTEGER PERIOD PERIOD INTEGER RBRACKET OF type_spec .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 123 resolved as shift
